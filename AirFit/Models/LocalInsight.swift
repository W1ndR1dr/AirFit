import Foundation
import SwiftData

/// AI-generated insight stored locally for Gemini Direct mode.
///
/// Mirrors the server's `Insight` dataclass from context_store.py.
/// Insights are generated by sending compact fitness data to Gemini API
/// and storing the AI's pattern analysis locally.
///
/// ## Categories
/// - `correlation`: Cross-domain patterns (highest value - things humans miss)
/// - `trend`: Directional movement over time
/// - `anomaly`: Something unusual that needs attention
/// - `milestone`: Achievement or progress worth celebrating
/// - `nudge`: Gentle reminder or suggestion
///
/// ## Tiers (1 = highest priority)
/// 1. Critical insights requiring immediate attention
/// 2. Important patterns affecting goals
/// 3. Noteworthy observations
/// 4. Nice-to-know information
/// 5. Minor observations
@Model
final class LocalInsight {
    var id: UUID
    var createdAt: Date

    // MARK: - Content

    /// Category: correlation, trend, anomaly, milestone, nudge
    var category: String

    /// Priority tier 1-5 (1 = highest)
    var tier: Int

    /// Short punchy title (max 8 words)
    var title: String

    /// Conversational explanation with data references
    var body: String

    // MARK: - Scoring

    /// How important is this insight (0.0-1.0)
    var importance: Double

    /// How confident is the AI in this insight (0.0-1.0)
    var confidence: Double

    /// How actionable is this insight (0.0-1.0)
    var actionability: Double

    // MARK: - Supporting Data (for sparklines)

    /// Metric name: protein, weight, calories, sleep, steps, volume
    var metricName: String?

    /// Data values for sparkline visualization (JSON-encoded [Double])
    var valuesData: Data?

    /// Current value of the metric
    var currentValue: Double?

    /// Previous value for comparison
    var previousValue: Double?

    /// Percentage change
    var changePct: Double?

    /// Target value if applicable
    var targetValue: Double?

    /// Trend slope (rate of change)
    var trendSlope: Double?

    // MARK: - Actions

    /// Suggested actions (JSON-encoded [String])
    var suggestedActionsData: Data?

    // MARK: - Engagement Tracking

    /// When this insight was shown to the user
    var surfacedAt: Date?

    /// User engagement: viewed, tapped, dismissed, acted
    var engagement: String?

    /// Whether user has dismissed this insight
    var isDismissed: Bool = false

    // MARK: - Initialization

    init(
        category: String,
        tier: Int,
        title: String,
        body: String,
        importance: Double = 0.5,
        confidence: Double = 0.5,
        actionability: Double = 0.5
    ) {
        self.id = UUID()
        self.createdAt = Date()
        self.category = category
        self.tier = tier
        self.title = title
        self.body = body
        self.importance = importance
        self.confidence = confidence
        self.actionability = actionability
    }

    // MARK: - Computed Properties

    /// Decoded sparkline values
    var values: [Double] {
        get {
            guard let data = valuesData else { return [] }
            return (try? JSONDecoder().decode([Double].self, from: data)) ?? []
        }
        set {
            valuesData = try? JSONEncoder().encode(newValue)
        }
    }

    /// Decoded suggested actions
    var suggestedActions: [String] {
        get {
            guard let data = suggestedActionsData else { return [] }
            return (try? JSONDecoder().decode([String].self, from: data)) ?? []
        }
        set {
            suggestedActionsData = try? JSONEncoder().encode(newValue)
        }
    }

    /// Overall score combining importance, confidence, and recency
    var score: Double {
        let recencyBoost = max(0, 1.0 - (Date().timeIntervalSince(createdAt) / (7 * 24 * 3600)))
        return (importance * 0.4 + confidence * 0.3 + recencyBoost * 0.3) * (1.0 / Double(tier))
    }

    /// Human-readable category name
    var categoryDisplayName: String {
        switch category {
        case "correlation": return "Pattern"
        case "trend": return "Trend"
        case "anomaly": return "Alert"
        case "milestone": return "Milestone"
        case "nudge": return "Tip"
        default: return category.capitalized
        }
    }
}

// MARK: - Query Helpers

extension LocalInsight {
    /// Get active (non-dismissed) insights
    static var active: Predicate<LocalInsight> {
        #Predicate<LocalInsight> { $0.isDismissed == false }
    }

    /// Get insights from the last N days
    static func recent(days: Int) -> Predicate<LocalInsight> {
        let cutoff = Calendar.current.date(byAdding: .day, value: -days, to: Date()) ?? Date()
        return #Predicate<LocalInsight> { $0.createdAt >= cutoff }
    }

    /// Get insights by category
    static func byCategory(_ category: String) -> Predicate<LocalInsight> {
        #Predicate<LocalInsight> { $0.category == category }
    }

    /// Get high-priority insights (tier 1-2)
    static var highPriority: Predicate<LocalInsight> {
        #Predicate<LocalInsight> { $0.tier <= 2 }
    }
}

// MARK: - Factory Methods

extension LocalInsight {
    /// Create from Gemini API response JSON
    static func from(json: [String: Any]) -> LocalInsight? {
        guard let title = json["title"] as? String,
              let body = json["body"] as? String,
              let category = json["category"] as? String else {
            return nil
        }

        let insight = LocalInsight(
            category: category,
            tier: json["tier"] as? Int ?? 3,
            title: title,
            body: body,
            importance: json["importance"] as? Double ?? 0.5,
            confidence: json["confidence"] as? Double ?? 0.5,
            actionability: json["actionability"] as? Double ?? 0.5
        )

        // Parse suggested actions
        if let actions = json["suggested_actions"] as? [String] {
            insight.suggestedActions = actions
        }

        // Parse supporting data
        if let supporting = json["supporting_data"] as? [String: Any] {
            insight.metricName = supporting["metric"] as? String
            insight.currentValue = supporting["current_value"] as? Double
            insight.previousValue = supporting["previous_value"] as? Double
            insight.changePct = supporting["change_pct"] as? Double
            insight.targetValue = supporting["target"] as? Double
            insight.trendSlope = supporting["trend_slope"] as? Double

            if let values = supporting["values"] as? [Double] {
                insight.values = values
            } else if let values = supporting["values"] as? [Int] {
                insight.values = values.map { Double($0) }
            }
        }

        return insight
    }

    /// Convert to dictionary for AI context injection
    func toDictionary() -> [String: Any] {
        var dict: [String: Any] = [
            "category": category,
            "tier": tier,
            "title": title,
            "body": body,
            "importance": importance,
            "created_at": ISO8601DateFormatter().string(from: createdAt)
        ]

        if !suggestedActions.isEmpty {
            dict["suggested_actions"] = suggestedActions
        }

        if let metric = metricName {
            var supporting: [String: Any] = ["metric": metric]
            if let current = currentValue { supporting["current_value"] = current }
            if let change = changePct { supporting["change_pct"] = change }
            if let target = targetValue { supporting["target"] = target }
            if !values.isEmpty { supporting["values"] = values }
            dict["supporting_data"] = supporting
        }

        return dict
    }
}

// MARK: - Deduplication

extension LocalInsight {
    /// Check if this insight's title is similar to another title.
    ///
    /// Uses Jaccard similarity (word overlap) for fast comparison.
    /// Matches server's `is_similar_title()` function.
    func isSimilarTo(title otherTitle: String, threshold: Double = 0.6) -> Bool {
        let myWords = Set(title.lowercased().split(separator: " ").map(String.init))
        let otherWords = Set(otherTitle.lowercased().split(separator: " ").map(String.init))

        guard !myWords.isEmpty && !otherWords.isEmpty else { return false }

        let intersection = myWords.intersection(otherWords).count
        let union = myWords.union(otherWords).count
        let similarity = Double(intersection) / Double(union)

        return similarity >= threshold
    }

    /// Check if this insight is a duplicate of any in the given list.
    func isDuplicateOf(existingTitles: [String]) -> Bool {
        for existing in existingTitles {
            if isSimilarTo(title: existing) {
                return true
            }
        }
        return false
    }
}
