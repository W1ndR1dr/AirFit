import XCTest
import SwiftData
@testable import AirFit

/// Integration tests for the complete persona system
/// Tests the full flow from conversation to coach interaction
final class PersonaSystemIntegrationTests: XCTestCase {
    
    var modelContext: ModelContext!
    var orchestrator: OnboardingOrchestrator!
    var coachEngine: CoachEngine!
    var aiService: AIService!
    var monitor: MonitoringService!
    var userService: UserService!
    var apiKeyManager: MockAPIKeyManager!
    
    override func setUp() async throws {
        await MainActor.run {
            super.setUp()
        }
        
        // Setup in-memory database
        let container = try ModelContainer(
            for: User.self, 
            ChatSession.self,
            ChatMessage.self,
            CoachMessage.self,
            ConversationSession.self,
            configurations: .init(isStoredInMemoryOnly: true)
        )
        modelContext = ModelContext(container)
        
        // Initialize services
        apiKeyManager = MockAPIKeyManager()
        apiKeyManager.stubbedGetAllConfiguredProvidersResult = [.anthropic]
        
        // Initialize LLM orchestrator and AI service
        let llmOrchestrator = LLMOrchestrator(apiKeyManager: apiKeyManager)
        aiService = AIService(llmOrchestrator: llmOrchestrator)
        
        // Initialize user service
        userService = UserService(modelContext: modelContext)
        
        // Initialize orchestrator with required dependencies
        orchestrator = OnboardingOrchestrator(
            modelContext: modelContext,
            apiKeyManager: apiKeyManager,
            userService: userService
        )
        
        // Initialize coach engine
        coachEngine = CoachEngine(
            aiService: aiService,
            modelContext: modelContext
        )
        
        monitor = MonitoringService.shared
    }
    
    override func tearDown() async throws {
        await monitor.resetMetrics()
        await MainActor.run {
            super.tearDown()
        }
    }
    
    // MARK: - End-to-End Tests
    
    /// Test complete onboarding flow from start to coach interaction
    func testCompleteOnboardingToCoachFlow() async throws {
        // Create test user
        let user = User(email: "test@example.com", name: "Test User")
        modelContext.insert(user)
        try modelContext.save()
        
        // Step 1: Start onboarding
        try await orchestrator.startOnboarding(userId: user.id)
        
        XCTAssertEqual(orchestrator.state, .conversationInProgress)
        
        // Step 2: Simulate conversation responses
        let conversationData = createRealisticConversationData(userId: user.id)
        
        // Step 3: Extract insights
        let insights = createRealisticInsights()
        
        // Step 4: Generate persona
        let startTime = CFAbsoluteTimeGetCurrent()
        
        // Create persona synthesizer for testing
        let llmOrchestrator = LLMOrchestrator(apiKeyManager: apiKeyManager)
        let synthesizer = await PersonaSynthesizer(llmOrchestrator: llmOrchestrator)
        
        // Generate persona directly
        let persona = try await synthesizer.synthesizePersona(
            from: conversationData,
            insights: insights
        )
        
        let generationDuration = CFAbsoluteTimeGetCurrent() - startTime
        
        // Verify performance
        XCTAssertLessThan(generationDuration, 5.0, "Persona generation exceeded 5s target")
        XCTAssertNotNil(persona)
        
        // Step 5: Save persona to user
        user.activePersona = Data() // Simulate persona data storage
        try modelContext.save()
        
        // Step 6: Create coach session
        let session = ChatSession(userId: user.id)
        modelContext.insert(session)
        
        // Step 7: Test coach interaction
        let userMessage = ChatMessage(
            role: .user,
            content: "I want to start working out but I'm not sure where to begin",
            sessionID: session.id
        )
        modelContext.insert(userMessage)
        
        let coachResponse = try await coachEngine.generateResponse(
            to: userMessage,
            in: session,
            for: user
        )
        
        // Verify coach response
        XCTAssertNotNil(coachResponse)
        XCTAssertFalse(coachResponse.content.isEmpty)
        XCTAssertTrue(coachResponse.content.contains(persona.name) || 
                     coachResponse.role == .assistant,
                     "Coach should use persona characteristics")
        
        // Verify monitoring
        let metrics = await monitor.getMetricsSnapshot()
        XCTAssertGreaterThan(metrics.personaGeneration.count, 0)
        XCTAssertGreaterThan(metrics.apiPerformance.callCount, 0)
    }
    
    /// Test conversation recovery after interruption
    func testConversationRecovery() async throws {
        let user = User(email: "test@example.com", name: "Test User")
        modelContext.insert(user)
        try modelContext.save()
        
        // Start onboarding
        try await orchestrator.startOnboarding(userId: user.id)
        
        // Simulate interruption
        await orchestrator.pauseOnboarding()
        XCTAssertEqual(orchestrator.state, .paused)
        
        // Check recovery
        let recovery = OnboardingRecovery(modelContext: modelContext)
        let recoverableSession = try await recovery.findRecoverableSession(userId: user.id)
        
        XCTAssertNotNil(recoverableSession)
        XCTAssertTrue(recoverableSession!.canResume)
        
        // Resume
        try await orchestrator.resumeOnboarding()
        XCTAssertEqual(orchestrator.state, .conversationInProgress)
    }
    
    /// Test multi-provider fallback
    func testMultiProviderFallback() async throws {
        // Configure service with fallbacks
        // Note: fallback is now handled internally by AIService
        
        let request = AIRequest(
            systemPrompt: "You are a helpful assistant",
            userMessage: ChatMessage(role: .user, content: "Hello"),
            conversationHistory: [],
            availableFunctions: nil
        )
        
        // Even if primary fails, should get response
        let response = try await aiService.complete(request)
        XCTAssertFalse(response.isEmpty)
    }
    
    /// Test cache effectiveness across system
    func testSystemWideCaching() async throws {
        let request = AIRequest(
            systemPrompt: "You are a fitness coach",
            userMessage: ChatMessage(role: .user, content: "What's a good beginner workout?"),
            conversationHistory: [],
            availableFunctions: nil
        )
        
        // First request
        let start1 = CFAbsoluteTimeGetCurrent()
        let response1 = try await aiService.complete(request)
        let duration1 = CFAbsoluteTimeGetCurrent() - start1
        
        // Second request (should hit cache)
        let start2 = CFAbsoluteTimeGetCurrent()
        let response2 = try await aiService.complete(request)
        let duration2 = CFAbsoluteTimeGetCurrent() - start2
        
        XCTAssertEqual(response1, response2)
        XCTAssertLessThan(duration2, duration1 * 0.1, "Cache should make second request much faster")
        
        // Check cache stats
        let stats = await aiService.getCacheStats()
        XCTAssertGreaterThan(stats.hitRate, 0)
    }
    
    /// Test production monitoring integration
    func testProductionMonitoring() async throws {
        // Reset metrics
        await monitor.resetMetrics()
        
        // Perform various operations
        let user = User(email: "test@example.com", name: "Test User")
        modelContext.insert(user)
        
        // Track persona generation
        await monitor.trackPersonaGeneration(duration: 4.5, success: true, model: "claude-3-opus")
        
        // Track API calls
        await monitor.trackAPICall(
            provider: "anthropic",
            model: "claude-3-opus",
            duration: 2.3,
            success: true,
            cost: 0.024
        )
        
        // Track cache performance
        await monitor.trackCacheHit(hit: true)
        await monitor.trackCacheHit(hit: false)
        
        // Get metrics
        let metrics = await monitor.getMetricsSnapshot()
        
        XCTAssertEqual(metrics.personaGeneration.count, 1)
        XCTAssertEqual(metrics.personaGeneration.successCount, 1)
        XCTAssertLessThan(metrics.personaGeneration.averageDuration, 5.0)
        
        XCTAssertEqual(metrics.apiPerformance.callCount, 1)
        XCTAssertEqual(metrics.apiPerformance.totalCost, 0.024)
        
        XCTAssertEqual(metrics.cachePerformance.hitCount, 1)
        XCTAssertEqual(metrics.cachePerformance.missCount, 1)
        XCTAssertEqual(metrics.cachePerformance.hitRate, 0.5)
    }
    
    // MARK: - Error Scenarios
    
    /// Test system behavior under various error conditions
    func testErrorHandlingAcrossSystem() async throws {
        let user = User(email: "test@example.com", name: "Test User")
        modelContext.insert(user)
        
        // Test network error during onboarding
        do {
            // Force network error
            try await orchestrator.startOnboarding(userId: user.id)
            // In real scenario, network would fail here
        } catch {
            // Verify error is properly categorized
            if let onboardingError = error as? OnboardingOrchestratorError {
                let recovery = OnboardingRecovery(modelContext: modelContext)
                let canRecover = await recovery.canRecover(
                    from: onboardingError,
                    sessionId: UUID().uuidString
                )
                XCTAssertTrue(canRecover, "Should be able to recover from network errors")
            }
        }
        
        // Test monitoring captures errors
        await monitor.trackError(
            NSError(domain: "TestError", code: -1),
            context: "Integration test"
        )
        
        let metrics = await monitor.getMetricsSnapshot()
        XCTAssertFalse(metrics.errors.isEmpty)
    }
    
    // MARK: - Helper Methods
    
    private func createRealisticConversationData(userId: UUID) -> ConversationData {
        ConversationData(
            sessionId: UUID(),
            userId: userId,
            startTime: Date(),
            endTime: Date(),
            summary: "User wants to get fit, prefers morning workouts, intermediate fitness level",
            extractedData: [
                "primaryGoal": "Lose 20 pounds and build muscle",
                "fitnessLevel": "intermediate",
                "preferences": ["morning workouts", "gym access", "45-60 min sessions"],
                "constraints": ["bad knees", "vegetarian diet"],
                "motivation": "upcoming wedding in 6 months"
            ],
            responses: [
                ConversationResponse(
                    nodeId: "goals",
                    question: "What brings you to AirFit today?",
                    answer: "I'm getting married in 6 months and want to look and feel my best. I need to lose about 20 pounds and tone up.",
                    timestamp: Date()
                ),
                ConversationResponse(
                    nodeId: "experience",
                    question: "Tell me about your fitness experience",
                    answer: "I used to work out regularly in college but haven't been consistent for the past 2 years. I know the basics but need structure and motivation.",
                    timestamp: Date()
                ),
                ConversationResponse(
                    nodeId: "preferences",
                    question: "When do you prefer to exercise?",
                    answer: "I'm definitely a morning person. I like to get my workout done before work, usually around 6 AM.",
                    timestamp: Date()
                )
            ],
            nodeCount: 12,
            completionPercentage: 100
        )
    }
    
    private func createRealisticInsights() -> ConversationPersonalityInsights {
        ConversationPersonalityInsights(
            dominantTraits: ["goal-oriented", "supportive", "structured"],
            communicationStyle: .conversational,
            motivationType: .achievement, // Wedding deadline
            energyLevel: .high, // Morning person
            preferredComplexity: .moderate,
            emotionalTone: ["encouraging", "understanding"],
            stressResponse: .needsSupport,
            preferredTimes: ["early morning", "pre-work"],
            extractedAt: Date()
        )
    }
}

// MARK: - Test Extensions

extension PersonaSynthesizer {
    /// Test helper to generate cache key
    private func generateCacheKey(conversationData: ConversationData, insights: ConversationPersonalityInsights) -> String {
        // Simple key generation for testing
        return "\(conversationData.userName)-\(insights.dominantTraits.joined())"
    }
}