Guide to Composing a CLAUDE.md for Claude Code in Cursor

When using Claude Code (Anthropic’s AI coding assistant) within the Cursor editor, a well-crafted CLAUDE.md file can dramatically improve the quality and consistency of the generated code. This file serves as a project-specific instruction manual for the AI – something you’d give a human developer to get them up to speed ￼. Below, we outline best practices (as of 2024–2025) for structuring CLAUDE.md and guiding Claude 4 models to build idiomatic iOS, macOS, and watchOS apps from plain English instructions.

What is CLAUDE.md and Why It Matters

CLAUDE.md is a Markdown file placed in your project’s repository that Claude automatically reads as context ￼. It acts as persistent memory for project-wide guidelines, analogous to Cursor’s “.cursorrules” file for its native AI agent ￼. By default, Claude Code will load this file every time it works on your code, ensuring your instructions and preferences are always considered. In other words, CLAUDE.md provides guidance to Claude Code when working with code in this repository, covering things like coding style, architecture, and important commands ￼.

For non-coders, this means you can steer the AI with high-level directions without writing code yourself. A good CLAUDE.md helps the assistant maintain consistent style and architecture across the entire codebase. Without it (or a similar “rules” file), the AI might make ad-hoc decisions that vary from file to file – whereas with a clear spec, it will follow the established patterns (much like a human developer would) ￼. In large projects where not everything fits in the model’s immediate context, a CLAUDE.md (or spec) is essential ￼ for coherence.

Key capabilities enabled by CLAUDE.md:
	•	Project memory: Claude remembers preferred patterns, conventions, and past decisions by referring to CLAUDE.md ￼. This prevents it from reintroducing earlier mistakes or outdated approaches (provided you document those decisions).
	•	Auto-inclusion of context: You can even reference other files or documentation from CLAUDE.md. For example, using a syntax like u/path/to/file.md in CLAUDE.md will prompt Claude to load that file’s content as additional context ￼. This is useful if you have detailed requirements or design docs – include them by reference instead of copy-pasting large text.
	•	Unified guidance: It’s a single source of truth for how the AI should behave on your project, so you don’t have to repeat foundational instructions in every prompt. Claude Code’s /init command actually generates a starter CLAUDE.md by analyzing your repo (listing build steps, style guides, etc.) ￼ – you can then edit and refine it.

Structuring CLAUDE.md for Claude 4 (2024–2025 Best Practices)

Claude’s latest models (e.g. Claude 4 “Opus” and “Sonnet” released May 2025) have huge context windows and improved reasoning, but they still benefit greatly from a well-structured CLAUDE.md. Anthropic recommends keeping this file concise (around 20 lines) but packed with high-value info ￼. Focus on guidelines that steer architecture, style, and tooling. Here are the key sections and content to include:
	•	Project Overview & Scope: A brief description of the app and its purpose. For example: “This project is a SwiftUI application suite (iOS, macOS, watchOS) for tracking personal fitness goals. It includes an iPhone app, a Mac Catalyst app, and a watchOS companion, sharing most of the business logic.” This gives Claude context about the domain and multi-platform nature of the project, helping it reason about shared code versus platform-specific code.
	•	Build & Run Instructions: List the commands or steps to build, run, and test the app ￼. This helps Claude use the correct tools and verify its work. For instance, specify how to run the iOS app via Xcode or xcodebuild, how to run unit tests, and any linting steps:
	•	“To build and run the iOS app, use Xcode 15 or run xcodebuild -scheme MyApp -destination 'platform=iOS Simulator,name=iPhone 15' build. For macOS, build the MyAppMac target in Xcode. Run tests with xcodebuild -scheme MyAppTests -test.”
	•	If there are command-line tools or scripts (like a build script, or a Supabase setup script in Thomas Ricouard’s example), list them here. This ensures Claude knows how to validate the code it writes (e.g. compiling to check for errors ￼).
	•	Code Style Guidelines: Include your preferred coding conventions – essentially, the “linter rules” or style manual for the project ￼. This might cover naming conventions, formatting, and language idioms:
	•	“Use Swift’s standard naming conventions (UpperCamelCase for types, lowerCamelCase for variables and functions). Prefer clear, descriptive names for clarity ￼. Keep functions under 50 lines and follow single-responsibility principle.”
	•	“Follow idiomatic SwiftUI patterns (e.g., use @State and @EnvironmentObject for state management where appropriate). No force-unwrapping of optionals; handle errors gracefully with do/try or Result types.”
	•	If you have a SwiftLint config or specific style requirements, summarize them. For example: “Max line length 100. Use 4-space indentation. Organize imports alphabetically. Include documentation comments for public APIs.”
	•	Architecture & Design Patterns: Clearly state the architecture to follow (this is crucial for generating scalable, well-structured code):
	•	“Use an MVVM architecture for SwiftUI views: each screen has a View struct and a corresponding ViewModel class (ObservableObject) to handle logic.” Indicating a pattern like MVVM helps the AI separate UI code from business logic, leading to more maintainable code.
	•	“Separate concerns into layers: Networking code goes in a Services folder (e.g., a APIClient class), business logic in ViewModels, and data persistence in a Data folder.” By specifying the project structure and file organization, you guide Claude to put code in the right place ￼ (e.g., model structs in a Models group, extensions in an Extensions folder, etc.). This prevents the AI from dumping everything in one file and encourages a scalable codebase.
	•	“Follow Apple’s best practices for SwiftUI: use the latest Swift concurrency (async/await) for asynchronous tasks, and adopt Combine or Swift Async Algorithms for reactive streams as needed.” This ensures the AI produces modern, efficient code rather than outdated patterns.
	•	“For multi-platform targets: share code in a cross-platform module whenever possible. Use #if os(iOS) checks or separate files for platform-specific code (e.g., WatchKit specifics).” This tells Claude how to approach the multi-target aspect (e.g., avoid duplicating logic for iOS and macOS, instead factor it into a shared framework or using SwiftUI’s multiplatform capabilities).
	•	Preferred APIs & Modern Practices: If certain frameworks or approaches should be used (or avoided), mention them. The model’s training data might include older usage, so it helps to nudge it toward the current best practices:
	•	“Use SwiftUI’s new @Observable macro (Swift 5.9+) for simple observable objects instead of the older Combine @Published properties, whenever possible.” For example, some users found Claude would otherwise default to “your granddad’s SwiftUI code” (older patterns) unless instructed ￼. By stating this, you ensure Claude writes more future-proof code.
	•	“Prefer native frameworks over external dependencies unless specified. (e.g., use URLSession for networking and Codable for JSON parsing, instead of requiring third-party libraries).”
	•	“Utilize Apple’s Human Interface Guidelines: e.g., adhere to recommended spacing, icons, and accessibility standards in the UI.” (This is more high-level, but it can influence Claude to produce more polished UI code.)
	•	Testing & Debugging Instructions: Guide Claude on how to verify its output:
	•	“After implementing a feature, ensure to run the tests (swift test or Xcode tests) and fix any failing cases.” If you want, mention specific test files or key test scenarios to cover (for a non-coder, you might describe the behavior and let Claude write the tests).
	•	“If a runtime error occurs (e.g. a crash), run the app with Xcode’s debugger or print logs to identify the cause, then fix it.” – This reminds the AI it can enter a debugging mode. Claude Code’s agent can execute commands and read error output, but you might need to instruct it in plain English to do so.
	•	If you have particular debugging tools (say, an MCP debug server or specific logging requirements), include them. Otherwise, a general instruction to systematically address errors is helpful (so the AI doesn’t just ignore errors).
	•	Project-specific Context: Finally, include any domain knowledge or requirements the AI should keep in mind:
	•	For example, “This app integrates with Supabase backend – use the Supabase Swift SDK for database operations.” Or, “The watchOS app should operate independently of the iPhone after initial sync.” These specifics ensure Claude’s code aligns with your functional needs from the start.
	•	If certain files are especially important (core schema, config files), mention them: “Models/Workout.swift defines the core data model for workouts – all fitness data revolves around this.” Claude can then prioritize consistency around these core files ￼.

Remember to prefix the file with a top-level title and explanation as Claude’s /init suggests (Claude Code often adds a heading): for example:

# CLAUDE.md

This file provides guidance to Claude Code when working with code in this repository. 

By organizing CLAUDE.md into sections (Overview, Build, Style, Architecture, etc.), you make it easy for the AI to parse and follow. Include only information that you want the AI to always consider. Avoid overly detailed feature specs here (those can be given as prompts when needed), and instead focus on the high-level rules and preferences that persist throughout the project.

Example CLAUDE.md Template (SwiftUI Project)

To illustrate, here’s a simplified example of what a CLAUDE.md might look like for a SwiftUI multi-platform app:

# CLAUDE.md

This file provides high-level guidance to Claude when coding this project.

## Project Summary
- **App Name:** FitTrack (iOS, macOS, and watchOS SwiftUI app for fitness tracking).
- **Purpose:** Log workouts and display health metrics (heart rate, steps) in real-time.

## Build & Run
- Use Xcode 15+. iOS/macOS targets share code in `Shared/` directory.
- **Build:** `xcodebuild -scheme FitTrack -destination 'platform=iOS Simulator,name=iPhone 15' build`
- **Test:** Run all unit tests with `xcodebuild -scheme FitTrackTests -test` (ensure all tests pass).
- **Run watchOS:** Build and run on a paired simulator; the watchOS app should sync via HealthKit.

## Architecture & Structure
- **Pattern:** Use MVVM – separate SwiftUI Views from business logic in ViewModel classes (`: ObservableObject`).
- **Folders:** `Models/` for data models, `ViewModels/` for logic, `Views/` for UI, `Services/` for networking/health data.
- **State:** Use SwiftUI state management (@State, @ObservableObject). Prefer the new `@Observable` macro for simple models instead of older @Published where applicable.
- **Concurrency:** Use async/await for async calls (e.g., fetching health data or API calls), and handle errors with do/catch. Avoid using deprecated APIs.

## Coding Style
- Follow Swift API Design Guidelines for naming (CamelCase for types, etc.).
- Write **idiomatic SwiftUI**: use modifiers and view compositions rather than massive view structs. Keep functions and structs focused and small for readability.
- Maintain consistent style across platforms – e.g., if iOS and macOS share a feature, implement it in the same way for both.
- Include comments for non-obvious logic and **document public interfaces** (using /// doc comments) for maintainability.

## Testing & Debugging
- Include unit tests for critical logic (e.g., `WorkoutCalculatorTests` for calorie calculations).
- If a test fails or a build error occurs, address it immediately. (You can have Claude diagnose test failures by reading the output.)
- Ensure the app meets Apple’s guidelines (no hard-coded strings for user-visible text – use Localizable.strings if needed, etc.). 

## Additional Guidelines
- **Frameworks:** Use HealthKit for step count and heart rate. No third-party analytics – use Apple’s OS logging if needed.
- **UX:** Adhere to Human Interface Guidelines: for example, use SF Symbols for icons, and ensure font sizes adjust for accessibility.
- **Persistence:** Use Core Data for storing workouts locally (with iCloud sync) – core data model is defined in `Models/Workout.xcdatamodeld`.

The above is just an example – your CLAUDE.md will vary based on your project. The key is it provides a blueprint for Claude to follow, so that when you later ask it for features (“Add a screen to display weekly summary of workouts”) it already knows how to fit that into the project structure and style.

Guiding Claude with Effective Prompts in Cursor

With CLAUDE.md in place, you can now focus on giving clear, plain-English instructions to build out the app. Here are best practices for prompting Claude (Claude 4 models) to generate an Apple codebase that is idiomatic and robust:
	•	Iterative Development – Plan then Code: Don’t jump straight into code generation for complex apps. A great approach is the “Explore-Plan-Code-Commit” workflow ￼:
	1.	Explore/Read: Ask Claude to analyze existing files or requirements first. For example: “Read the CLAUDE.md and the empty Xcode project structure, and confirm you understand the project goals.” Claude can also read a design spec or API doc if you provide it (you might use the u/ include syntax in CLAUDE.md or simply paste content in a prompt).
	2.	Plan: Have Claude propose an implementation plan before writing code. You can literally prompt: “Please outline a plan. Think hard about the app structure and list all the components (views, models, viewmodels, etc.) you will create to fulfill the requirements.” Using phrases like “think hard” can trigger Claude’s extended reasoning mode for deeper planning ￼. Review this plan and edit or approve it. This step is crucial for non-coders: it lets you see in plain language what will be built and adjust it if it’s not what you envisioned.
	3.	Code: Once the plan looks good, instruct Claude to implement it. You might say: “Great, please implement this plan. Create the files and code for each item.” Claude will then generate code for each file, typically presenting diffs or file contents which you apply in Cursor. Thanks to CLAUDE.md, it will already follow the specified architecture and style (e.g., placing files in the right folders, using MVVM, etc.). As it codes, Claude 4 is capable of keeping track of multiple files at once (multi-file awareness) and even doing parallel tool use (executing multiple steps together) to be efficient ￼.
	4.	Commit/Review: After code generation, ask Claude to verify and “commit” the changes. For example, “Run the build and tests, and let me know if everything passes. Then summarize the changes.” Claude Code will often show you a diff of changes for review before applying them, so you remain in control ￼. Always take a moment to review the diff/output – like reviewing a junior developer’s work – before finalizing.
	•	Be Specific in Your Requests: Claude excels when given clear, detailed instructions ￼. Vague prompts yield more guesswork from the AI. Instead of “Add Apple Watch support”, break it down and specify the pieces: “Add a watchOS target with a SwiftUI interface showing today’s step count. The watch app should sync steps from HealthKit and display a complication with the step count.” The specificity about features and frameworks (HealthKit, complication, etc.) will align the output with your expectations. Similarly, when asking for tests or edge cases, describe them concretely – e.g. “Write a unit test for the login view model that covers a failed login attempt (wrong password) and ensures an error message is set.” This level of detail guides Claude to produce exactly what you need ￼.
	•	Leverage Visual Aids and References: If you have design mockups or any visual reference, you can provide those to Claude to improve UI fidelity. Claude 4 can accept images – for instance, you could paste a screenshot of a Figma design for a screen. Prompt Claude with something like: “Here is the design for the dashboard screen (attached image). Use SwiftUI to implement a UI that matches this design as closely as possible.” This helps the assistant understand layout and styling requirements. Anthropic notes that providing screenshots or design files can help Claude iterate the UI until it matches your vision ￼. In Cursor, you might drag-and-drop an image into the chat if supported, or provide a URL to the image. Likewise, mention specific Apple UI guidelines as needed (for example, “The text should use the large title font style, and the button should use a system blue color”). Claude can incorporate these details into the code it generates.
	•	Use Cursor’s Tools for Context: Working in Cursor, you can take advantage of the IDE-like environment. For example, you can open files side by side or use Cursor’s search, then tell Claude “Open WorkoutModel.swift – ensure the new code uses the properties defined there”. By referencing filenames or using Cursor’s tab-completion to insert file paths in your prompt, you make sure Claude looks at the right context ￼. Claude Code integrated in Cursor can directly access the project’s files, so feel free to ask it things like “Refer to CLAUDE.md and confirm our coding style before proceeding.” (In fact, Claude does this automatically).
	•	Iterate and Refine in Plain English: As you build the app, treat Claude like a fast but somewhat novice developer – you need to review its work and give feedback ￼ ￼. The good news is you can do this in plain English:
	•	Error Correction: If the code doesn’t compile or a runtime error occurs, simply describe the issue to Claude. For instance: “The build failed with an error: ‘unknown type HealthKitManager’. Please fix this.” Claude will typically identify that perhaps it forgot to create a HealthKitManager class or missed an import, and then generate the fix. You can also share the exact compiler error or stack trace – Claude can parse error messages and suggest solutions. One effective debugging approach a user reported is to explicitly ask the AI how to debug before it jumps to changes, e.g.: “The app crashes when tapping Start Workout. How can we figure out the cause?” This may prompt Claude to propose adding print logs or using the debugger, rather than blindly editing code ￼. In general, engage in a dialogue: “It looks like the UI is not updating after data sync. What could be wrong?” Claude might then explain potential causes (perhaps a missing DispatchQueue.main.async for a UI update) and offer a code change.
	•	Refactoring and Improvements: You can ask Claude in plain language to improve the code quality. For example: “Refactor the Workout model and related code to improve maintainability – maybe extract common code, ensure functions are not too large, and add comments where useful.” Claude will use the guidelines from CLAUDE.md (like keeping functions short, single-responsibility, etc.) to make suggestions ￼ ￼. It might, for instance, split a large function into smaller ones or introduce a utility class if it sees repetition. Always review these refactorings to ensure they make sense. Claude 4 is quite powerful at such tasks – it can even perform project-wide audits (e.g., find all overly-long functions, detect duplicate logic, etc.) if asked ￼.
	•	Plain English Explanations: If you as a non-coder are unsure why the AI did something or how a piece of code works, just ask. “Explain what the WorkoutCalculator.calculateCalories() function is doing.” Claude will happily walk through the code logic for you. This can build your understanding and help you decide if the implementation meets your needs or if it should be adjusted. It’s like having an expert tutor alongside the coder.
	•	Update CLAUDE.md as You Learn Preferences: Treat CLAUDE.md as a living document. If you discover the AI keeps doing something you dislike, add a rule in CLAUDE.md to prevent it in the future. As one early adopter noted, if Claude repeatedly chose a convoluted approach for something, they would tell it to update CLAUDE.md with a new guideline, and it “didn’t do it again” ￼. For example, if you see it using an outdated API or an inefficient algorithm, you might append to CLAUDE.md: “Prefer using modern Swift APIs (e.g., use Date().formatted() instead of deprecated DateFormatter APIs).” Claude will then remember this guidance going forward. This iterative improvement means the longer you work with Claude, the more tailored it becomes to your project’s standards and your personal preferences – truly like an intern learning on the job ￼.
	•	Verify and Test Frequently: Since you’re not coding by hand, make sure to run the app and tests regularly. Claude Code (especially Claude 4) is quite reliable, but it’s not infallible – it might introduce subtle bugs or logic that doesn’t exactly meet the requirement. By testing in small increments (for example, after implementing each feature or screen), you can catch issues early and ask Claude to fix them. In Cursor, you can compile and even run the app if you have the environment set up; use that to your advantage. Each time, report any problems in simple terms to Claude and it will assist in debugging. This tight feedback loop is where Cursor’s integration shines: you can code, run, and debug all in one place with Claude’s help.

Combining Claude Code with Cursor’s Features

Cursor is an AI-augmented code editor (a VS Code fork) that can use Claude as a backend model. When you use Claude Code within Cursor, you get the best of both worlds: Claude’s powerful coding abilities and Cursor’s convenient interface. Here are some tips on leveraging both effectively:
	•	Use Claude for Complex, Global Tasks: Claude 4 (especially the Opus variant) can handle long context and complex reasoning ￼ ￼. This makes it ideal for tasks like generating multiple files, doing architecture-wide refactors, or analyzing how changes in one part of the app affect another. In practice, when you have a big feature to add or a tricky bug to fix that touches many components, lean on the Claude integration. For example, “Add offline support across the app” might require changes in data storage, UI, and sync logic – Claude can plan and execute this across files thanks to the context provided by CLAUDE.md and its memory of the project.
	•	Use Cursor’s Native AI for Quick Edits or Suggestions: Cursor also has built-in AI features (historically using models like GPT). These can be handy for small, focused tasks – such as completing a single line, doing a quick regex, or explaining a snippet – especially if you don’t need Claude’s full reasoning power. Since you’re already using Claude, you might not need Cursor’s default AI much, but it’s there as a backup. For instance, if you have Cursor’s inline completion turned on, it might suggest a line of code as you type; you can accept those for convenience in straightforward situations. However, for anything substantial or anything requiring understanding the whole project, prefer explicitly invoking Claude (via the chat or command palette in Cursor). Users have noted that Claude’s direct integration tends to maintain more context and make fewer “editing mistakes” than some default AI flows ￼.
	•	Take Advantage of Cursor’s UI for Control: Cursor provides features like a diff viewer, file tree, and the ability to approve or revert changes. Use these alongside Claude’s suggestions:
	•	Diff Review: When Claude proposes changes, look at the diff in Cursor. This is your chance to spot if it misunderstood something. (For a non-coder, diffs may be intimidating, but focus on the high-level: did it touch files you didn’t expect? Does the structure of the code align with what you asked for? If something looks off, ask Claude about it or request modifications.)
	•	Version Control: If your project is in Git, commit working changes in small chunks. That way, if Claude’s subsequent edits introduce a problem, you can easily roll back in Cursor. Claude can even write commit messages or summarizations of changes if you ask – “Summarize the changes in a commit message”.
	•	Cursor Commands and Shortcuts: Cursor has handy shortcuts (like running tests, searching the project, or formatting code) which can complement Claude’s work. For instance, after Claude generates code, you might hit the “format document” command to ensure spacing is consistent – though Claude typically follows the style rules you gave it. If Cursor flags a syntax error or warning (using its built-in compiler or linter integration), use that feedback: you can tell Claude, “The editor is showing a warning about this line – please fix it.” This melds Cursor’s real-time feedback with Claude’s fixing ability.
	•	Manage Model Usage and Costs: Using Claude via Cursor does require an API key or subscription (e.g., Claude.ai or Anthropic API). Keep an eye on how many requests you make – Claude 4 is powerful but not cheap. However, one advantage of working through Claude Code is it can sometimes reduce back-and-forth queries by doing more in one go (thanks to reading CLAUDE.md and planning actions). Still, for very small tasks, you might opt for Cursor’s cheaper/faster completions if those are available. It’s a balance: many have found that the productivity boost of Claude Code is worth the higher token usage ￼ ￼, but if you have limited access, use it smartly (batch queries when possible, utilize the “plan” approach to minimize trial-and-error).
	•	Keep CLAUDE.md and Cursor’s Rules in Sync: If you previously used Cursor’s .cursorrules file or any VSCode settings, consider porting relevant rules into CLAUDE.md. Claude’s /init process even attempts to import Cursor rules or GitHub Copilot instructions if it finds them ￼. The goal is to have one coherent set of instructions. Having conflicting or duplicate instructions in multiple places can confuse things. Since you’re focusing on Claude, CLAUDE.md should be the master reference. (Conversely, if you ever switch to another AI tool, you could adapt the same content to that format – the concept is similar across platforms).

In summary, use Claude’s strengths for understanding and generating project-wide code, and use Cursor’s environment for fine-tuning and verifying those changes. Claude Code as a plugin essentially turns Cursor into a Claude-native IDE ￼, giving you full context reasoning and inline edits without leaving the editor. With a solid CLAUDE.md to guide the AI, and interactive prompting to refine the output, you can effectively build a complete SwiftUI codebase through natural language – truly coding by conversation!

Community Tips and Workflow Optimizations

Early adopters of Claude Code and Cursor have shared valuable tips which can help non-coders work more effectively:
	•	Think of Claude as a Fast Junior Developer: It will do a lot of grunt work quickly, but you are the “project lead” who must review and guide. Always verify the code it produces (run it, test it) – “trust, but verify”. This mindset helps catch issues early and reminds you to provide oversight ￼.
	•	Progressive Enhancement: Start with simple prompts and gradually increase complexity. One community member advised progressively building up: first ask Claude to suggest the high-level system design, then flesh out each part step by step ￼. This prevents you from getting overwhelmed and helps Claude focus on one aspect at a time.
	•	Use Plain Language for Everything: Don’t worry about using correct programming jargon for prompts – explain features or problems as if you were describing them to another person. Claude is trained to understand intent even if you’re not using precise technical terms. For example, “Make the list scrollable and refresh when pulled down” is perfectly fine; Claude will infer you mean using SwiftUI’s List with refreshable modifier.
	•	Handle Errors Gracefully: If Claude’s code fails, it’s not a one-shot deal. Treat errors as new information for Claude. Provide the error message or describe the unexpected behavior, and let it suggest a fix. Often a small clarification in your instructions or an added rule in CLAUDE.md can resolve systematic issues.
	•	Stay Up-to-Date: The AI’s capabilities improve over time – Claude 4 is more capable than Claude 2, etc. Keep an eye on updates from Anthropic or the Cursor community. New model versions might handle Apple frameworks even better or introduce new tools. For instance, Claude 4 models have huge 100K token contexts, which means you could feed in large portions of Apple’s documentation or entire design documents if needed. Using that wisely can further enhance results.
	•	Community & Resources: Engage with communities (Discord, Reddit, forums) for Cursor and Claude. Users frequently share prompt examples, success stories, and failures. For example, some have shared how Claude 4 handled SwiftUI views much better than previous versions ￼ ￼, and others have pointed out where it still falls short (such as missing some new SwiftUI features if not nudged ￼). Learning from these insights can save you time. If you hit a roadblock, chances are someone else did and found a workaround.

By following these best practices – crafting a focused CLAUDE.md, giving clear instructions, and iterating with Claude’s help – even a non-coder can orchestrate the creation of a full SwiftUI codebase. Claude will handle the heavy lifting of writing code, but your role is to guide it with vision and clarity. Keep the communication flowing: update the CLAUDE.md when needed, ask Claude to clarify anything unclear, and step by step, you’ll see your iOS/macOS/watchOS app take shape.

Sources:
	•	Anthropic Claude Code Documentation and Updates ￼ ￼ ￼ ￼
	•	Cursor & Claude User Experiences (Reddit, HN, Blogs) on effective CLAUDE.md usage ￼ ￼ ￼ ￼
	•	SwiftUI AI Coding Case Studies (Thomas Ricouard’s and others’ experiments with Claude 4) ￼ ￼
	•	Community Tips for AI-Assisted Coding Workflow ￼ ￼ ￼